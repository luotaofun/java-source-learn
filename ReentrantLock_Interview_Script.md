## ReentrantLock (可重入锁) 

### 1. ReentrantLock 是什么？

`ReentrantLock`，中文翻译为“可重入锁”，是 Java `java.util.concurrent.locks` 包下的一个高级同步锁实现。它与 `synchronized` 关键字类似，都用于控制对共享资源的并发访问，但 `ReentrantLock` 提供了更强大和更灵活的功能。

所谓“可重入”，指的是**同一个线程在已经持有该锁的情况下，可以再次成功获取这把锁，而不会被自己阻塞**。每次重入，锁的持有计数会增加；相应地，每次释放锁，计数会减少，直到计数归零，锁才被真正释放，其他线程才能获取。因此，它也被称为“递归锁”。

### 2. 形象化的场景描述

我们可以用一个生活中的例子来理解“可重入”这个概念，就像“摇号上牌照”的比喻，或者我们可以想象进入一个需要钥匙的房子：

*   **获取锁**：就好比你用一把钥匙打开了房门，进入了房子。
*   **可重入性**：如果你进入客厅后，又想进入卧室，而卧室的门也需要同一把钥匙（同一个锁实例）。如果你可以直接进入卧室，无需先退出房子再重新用钥匙开门，那么这把钥匙（锁）就是“可重入”的。你第一次开门进入房子后，相当于获取了锁；当你想从客厅进入卧室时，因为你已经是房子的合法进入者（持有锁的线程），你可以再次“使用”这把钥匙（重入锁），而不会被自己挡在门外。
*   **锁计数**：每次你通过一道受这把钥匙保护的门（重入一次），可以想象成计数器加一。当你离开时，每退出一道门，计数器减一。只有当你完全离开房子（所有重入都已解锁，计数器归零），这把钥匙才能被其他人使用。

如果每次进入房子的不同区域都需要你先退出房子，再重新用钥匙开门，那这个锁就不是可重入的。

### 3. 核心组件及其作用

`ReentrantLock` 的内部实现主要依赖于 **AQS (AbstractQueuedSynchronizer)** 这个强大的同步框架。

*   **AQS 状态 (State)**: AQS 内部维护一个 `int` 类型的 `state` 变量。在 `ReentrantLock` 中，这个 `state` 变量被用来表示锁的**持有计数**。
    *   当 `state` 为 0 时，表示锁未被任何线程持有。
    *   当一个线程首次获取锁时，`state` 会被设置为 1。
    *   当持有锁的线程再次获取该锁（重入）时，`state` 的值会递增。
*   **当前锁持有者 (ExclusiveOwnerThread)**: AQS 还会记录当前独占锁的线程。
*   **等待队列**: AQS 内部还维护一个线程等待队列，用于存放那些尝试获取锁但失败而被阻塞的线程。

当一个线程尝试获取锁时：
1.  如果锁是自由的 (`state == 0`)，则该线程获取锁，`state` 置为 1，并将该线程记录为 `ExclusiveOwnerThread`。
2.  如果锁已被当前线程持有 (`ExclusiveOwnerThread == currentThread()`)，则 `state` 递增，完成重入。
3.  如果锁已被其他线程持有，则当前线程通常会进入等待队列并被挂起。

### 4. 详细工作流程

**获取锁 (`lock()`):**

1.  线程调用 `lock()` 方法。
2.  `ReentrantLock` 会检查锁的 `state` 以及 `ExclusiveOwnerThread`。
3.  **非重入获取**：如果 `state` 为 0（锁是自由的），当前线程将尝试通过 CAS (Compare-And-Swap) 操作将 `state` 从 0 修改为 1。如果成功，当前线程就获得了锁，并被设置为 `ExclusiveOwnerThread`。
4.  **重入获取**：如果 `ExclusiveOwnerThread` 就是当前调用 `lock()` 的线程，那么 `state` 的值会加 1。这就是可重入的体现。
5.  **竞争失败**：如果锁已被其他线程持有，那么当前线程会根据锁的公平策略（如果是公平锁，会先检查等待队列；如果是非公平锁，会尝试抢占）来决定是直接尝试获取还是进入 AQS 的等待队列中排队等待。

**释放锁 (`unlock()`):**

1.  持有锁的线程调用 `unlock()` 方法。
2.  `state` 的值会减 1。
3.  只有当 `state` 的值减到 0 时，锁才被完全释放。此时，`ExclusiveOwnerThread` 会被置为 `null`，并且 AQS 会唤醒等待队列中的下一个线程（如果存在）来尝试获取锁。
4.  **重要实践**: `unlock()` 方法**必须**在 `finally` 块中调用，以确保即使在 `try` 块中发生异常，锁也一定会被释放。这是 `ReentrantLock` 相较于 `synchronized` 的一个重要区别和需要注意的点。我在 `MyLock.java` 的示例代码中也遵循了这个实践。

**`getHoldCount()` 方法**:
`ReentrantLock` 提供了一个 `getHoldCount()` 方法，可以查询当前线程持有此锁的次数

### 5. 示例图解 (文字描述)

如果用一个简单的图来表示 `ReentrantLock` 的重入过程：

```
线程 T1:
  lock.lock();      // T1 获取锁，state = 1, owner = T1
  // ... 执行操作 ...
  methodA() {
    lock.lock();    // T1 重入锁，state = 2, owner = T1
    // ... methodA 操作 ...
    lock.unlock();  // T1 释放一层锁，state = 1, owner = T1
  }
  // ... 执行操作 ...
  lock.unlock();    // T1 完全释放锁，state = 0, owner = null
```

这个图示表明，线程 T1 第一次获取锁后，`state` 变为 1。当它调用 `methodA` 并再次请求同一个锁时，由于是同一线程，它成功重入，`state` 变为 2。之后，每次 `unlock` 都会使 `state` 减 1，直到 `state` 归零，锁才对其他线程可用。

### 6. 技术优势

`ReentrantLock` 相较于 `synchronized` 关键字，具有以下主要优势：

1.  **避免死锁（由重入性本身带来的）**：
    *   如你资料中所述，如果一个线程已经持有一个锁，当它尝试再次获取同一个锁时（例如在递归调用或方法嵌套调用中），可重入性确保了线程不会自己将自己锁死。如果锁不是可重入的，这种情况就会导致死锁。
2.  **提高封装性与代码简洁性**：
    *   在需要多次进入同一同步代码块的复杂逻辑中，可重入性使得代码编写更自然，避免了不必要的频繁解锁和加锁操作。
3.  **可中断的锁获取 (`lockInterruptibly()`)**：
    *   等待获取锁的线程可以选择响应中断。如果一个线程在等待锁时被中断，它可以放弃等待并执行其他操作，这对于避免线程长时间阻塞非常有用。
4.  **可超时的锁获取 (`tryLock(long timeout, TimeUnit unit)`)**：
    *   线程可以尝试在指定的时间内获取锁，如果在超时时间内未能获取，则返回 `false`，而不是无限期等待。这在 `MyLock.java` 的 `ByTryLock` 示例中有所体现，它能有效防止死锁或提高系统响应性。
5.  **公平锁与非公平锁的选择**：
    *   `ReentrantLock` 允许在创建时指定锁的公平性。公平锁会按照线程请求锁的时间顺序来分配锁，而非公平锁则允许插队，可能会有更高的吞吐量但可能导致某些线程饥饿。`synchronized` 是非公平的。
6.  **条件变量 (`Condition`)**：
    *   `ReentrantLock` 可以关联一个或多个 `Condition` 对象（通过 `newCondition()` 方法创建）。`Condition` 提供了比 `Object` 的 `wait()`, `notify()`, `notifyAll()` 更强大和灵活的线程间协作机制，例如可以实现更精细的分组唤醒。

### 7. 经验分享

*   当需要**超时获取锁**或**可中断获取锁**的场景时，我会优先选择 `ReentrantLock`。例如，在一个高并发的系统中，如果某个资源竞争激烈，使用 `tryLock` 配合超时机制可以防止线程因长时间等待锁而耗尽，从而提高系统的健壮性。
*   在设计一些需要复杂同步控制的组件时，比如自定义的线程池或并发数据结构，`ReentrantLock` 及其 `Condition` 对象提供了比 `synchronized` 更细致的控制能力。
*   我始终强调，使用 `ReentrantLock` 时，**必须在 `finally` 块中调用 `unlock()`**。这是一个非常容易出错的地方，一旦忘记释放锁，就可能导致严重的线程阻塞甚至死锁问题。我会通过代码审查或静态分析工具来确保这一点。
*   对于公平性的选择，我会根据具体场景权衡。默认的非公平锁通常有更好的性能，但在某些需要保证处理顺序的场景下，公平锁是必要的，尽管它可能会带来一些性能开销。
*   `getHoldCount()` 方法虽然不常用在生产核心逻辑中，但在调试并发问题，特别是与重入相关的复杂逻辑时，它是一个非常有用的辅助工具，能帮助我们理解当前线程对锁的持有状态。
