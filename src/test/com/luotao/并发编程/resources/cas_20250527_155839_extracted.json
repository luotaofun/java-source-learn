["我是悟空", "大家好", "hello ,亲爱的小伙伴们", "在本章中我们将学习 c a as 原理", "这个 CAS 啊", "其实也有提到过", "它在我们前面的课程中呢", "也对它做了简单的介绍", "不过呢,可能还不够深入", "小伙伴们可能觉得还不够过瘾", "所以呢,我们在本章中单独为这个原理进行讲解", "他同时啊,也是我们面试中的常客", "因为它是很多原子类的底层原理", "同时也是乐观锁的原理", "所以啊,面试官比如说问你知道什么锁", "哎，你说 cs ,他再让你介绍一下 cs ", "他就继续问你原理", "你说了一个", "所以呀,我们通过本章的学习之后", "对这些问题就可以进行比较好的回答了", "首先让我们来看一下本章有哪几个部分", "第一个，我们会讲什么是 CS ", "看到三个字母你肯定不知道它是什么意思", "所以我们在第一个小节去讲解 cs 的概念", "诶，它的基本的作用", "然后呢，我们会进行一个案例演示", "案例演示就是说我们会写一个 cs 的代码", "然后呢，让两个线程去竞争", "哎，用这样的案例来演示出 ca as 的核心原理", "一个成功，一个失败", "并且还用 debug 的方式", "来看到他们两个线程内部的一些心理活动", "第三个呢，就是一个应用场景", "这个应用场景啊，我标红了", "它不是什么地方都能用的", "因为这个原理啊", "可以看出它是比较重要的", "它有它独特的适用场合", "然后呢，是第四个和第五个", "我们会在第三个部分进行讲解", "我们会以一个实例", "我们之前看过它，也用过它", "这个实例是 atomic integer ", "它背后就是利用了 cs ", "我们会从源码角度去分析", "但是呢，它是如何利用的", "并且看到它最终是如何一步一步调用", "成功地实现了线程安全的操作", "最后呢，我们还会介绍它的缺点", "这个缺点啊，我同样标红了", "因为这个缺点也是我们非常常考察的一个点", "cs 它虽然有好处", "所以我们在使用的时候", "但它也有非常明显的缺点", "一定要考虑到它的优缺点", "下面啊，就让我们进入到第一个部分", "然后综合判断", "那么首先呢，我们来讲一下 CAS ", "什么是 c a as ", "它首先它运用的场合一定是并发的", "是一种思想", "它的全称呢，叫做 compare and swap ", "用来实现线程安全的算法", "它是一种算法", "同时它也是一种 CPU 指令", "就可以完成比较并操作", "这一条指令", "比如说 compare and swap ", "这样的一个组合操作不会被打断", "所以啊， CAS 最主要的就是被用在了并发编程领域", "实现那些不能被打断的数据交换操作", "从而避免呢", "由于我们执行顺序是不能确定的", "我们多线程情况下", "所以执行顺序不能确定", "这种不可预知的这种问题", "因为是多线程嘛", "或者是某个线程被暂停了", "那么我们说一下他的思路啊", "cs 呢，它是有一个思路", "我首先一个", "它最主要的思路就是说", "我认为的这个 A 是我之前读取过来的", "我认为它应该是 A ", "读取过来之后", "然后我修改完了之后呢", "我在此基础上进行修改", "我会先判断它是不是 A ", "我想写回去的时候", "我就改成 BB 呢", "如果是的话", "如果不是 A ", "是我刚才计算出来的值", "被别人修改过了", "这就说明在我计算的过程中", "因为别人修改过了", "那我就不能修改了", "相当于并发的写了", "如果我再修改", "在这种情况下", "那么这种时候这个写入的结果呢，是错误的", "所以用了这样的一个最主要的思路之后呢", "就可以避免多人同时修改的时候的这种问题", "这就像我们在谈判的时候啊", "它是一种非常乐观的去协商的方式", "我会跟你商量", "如果你改了", "我会看你有没有改", "要比我们之前的那种互斥锁要好得多", "所以他们非常友好", "OK ，我就不改", "我们护士所呢，是我才不跟你握手呢", "我把这个资源牢牢的攥在我的手里", "所以呢，我也可以保证安全", "然后你也拿不到", "所以这是两种不同的思路", "那么接下来我们再看的具体一点", "它最主要的是有这三个部分需要他去关心的", "对于 C 、 A 、 S 而言啊", "一个是预期值", "一个是内存的值", "内存值呢，指的就是现在", "一个是要修改的值", "哎，这个值是多少", "然后呢，再去看看你现在这个 V 是不是 A ", "也就是说我希望你是 A ", "如果是的话", "我就把它改成 B ", "哎，满足我的期望", "我就什么都不做", "否则也就意味着 A 和 B 如果不相等", "那这是 C 、 A 、 S 的一个基本的思想", "最后呢，会返回我现在的 V ", "我们下面啊，用图解的方式", "让这个问题变得更加清晰", "那么比如说我们这边啊，有两个线程", "他们都想改动这个数", "分别用两个 CPU ", "然后啊，我们先来看左边这个", "他去执行的时候", "左边这个呢", "然后他去看是不是56", "并且想改成57", "他期望是56", "果然是56", "而当他改完之后", "于是呢，他就可以改动成功", "我们右边的这个 CPU 2它已经很慢了", "他这会儿刚刚轮到他", "可是实际上这个时候要么是56", "他会希望是55", "要么是已经被 CPU 1改过的57", "所以这个时候", "他肯定不是55了", "想把这个东西从55改成56", "OK ，你这边不是55", "虽然 CPU 2", "但是他发现了", "所以他不会去真正的把它改成56", "整个都是没有效果的", "也就是说这个操作呢", "所以是 sorry ， too late ", "这个时候他没有修改成功嘛", "比如说重试啊", "它可以有其他的操作", "但是这一次 cs 那一定是失败的", "这些都可以", "或者是报错啊", "下面啊，我们把这个问题再具体化一些", "CAS 实际上最终呢", "是要利用一些 CPU 的特殊指令的", "首先一个由 CPU 保证了它们的原子性", "因为这些指令呢", "其次一个指令就可以做好几件事情", "比如说这一个指令可以让它先比较", "而且这个指令由于有 CPU 保证了它的原子性", "然后呢再更新", "所以不会出现线程安全问题", "它的等价代码", "那么我们就来看一看啊", "有了这个等价代码之后", "我个人认为呢", "要比刚才的那些无论是图示还是文字呢", "小伙伴们理解起来啊", "都更加的容易", "实际上是一清二楚、一目了然的", "因为这个代码啊", "就让我们来看一看 cs 的等价与义", "把这个 cs 这一个东西把它拆开来", "看看他究竟做了哪些事情", "好，就让我们来新建一个包", "然后呢，在里面新建一个类", "这个包叫 ca as ", "这个类呢，名字叫做 simulated cs ", "就是模拟 CAS ", "什么意思啊", "我们在描述里面写一下", "实际上意思就是说", "模拟 ca as 操作等价代码", "它们是等价的", "就如我们之前学习 synchronized 的时候", "我们用 lock 去把它内部的一系列操作给展开来", "我们给他写了一个等价代码", "我们把它给展开来", "所以这里也是一样", "那么首先呢，我们在这里会有一个 int 的 value ", "然后呢，写一个方法", "这个方法就是 ca as 方法", "我们把它全名给写出来", "swap 是交换", "compare and swap ", "所以这个中文可以叫做比较并交换", "会有两个入参", "那么在这边呢", "第一个是期待的值", "我们把它叫做 expected value ", "是新的值", "第二个呢", "我希望把它改成一个值", "也就是我计算好的值", "在这里小伙伴们也看到了", "那改出来的呢，就叫做 new value ", "他用 synchronize 给修饰了", "这就意味着我们用这种代码的形式，诶", "但是整个啊，这个方法啊", "把它给实现了一个原子化的操作", "它都是保证原子的", "那如果我们不加它的话", "到了 CPU 那里", "我们只不过把它展开来", "那这里很有可能执行到一半就被打断", "以保证它是一个原子操作", "所以我们要加它", "实际上呢", "这整个方法它对应的是一条指令", "也就是对应的那个 CAS 指令", "而不是多条", "然后他需要做什么", "那么好，我们看看", "那比较的话，我要先拿到我现在的这个值", "首先它要比较，对不对", "也就是说我们用这个 old value 啊去取出来", "我现在的 value 取出来", "他去比较 if old value 和我们现在的期望", "取出来之后呢", "也就意味着我们期待它的值", "它的 value 是相等的话", "满足条件的话", "诶，正好是它现在的值", "说明在此期间没有人去动过它的值", "我就说明我可以修改", "于是呢，我就把 value 修改成我的 new value ", "然后呢，最后再返回，返回 old value ", "所以它最核心的内容呢，就在这里了", "小伙伴们可以看出啊", "他这个 compare ， compare 在哪里呢", "主要是 if ，也就是去比较它是不是一样的", "swap 呢，就是在这里把 value 改成我们的 new value ", "那么如果把这个方法视作一条指令的话", "这条指令实际上就是 CAS 在背后所做的操作", "我们再升一步", "好，有了这样的等价代码之后啊", "我们看一个具体的案例", "对不对", "我们假设有两个线程去竞争", "第一个是这个县城", "两个线程去竞争", "他尝试去找女神，说", "还同时呢", "我邀请你晚上去看电影", "满怀期待啊", "哎，你好", "哎，准备了一束鲜花", "不过呢，其实他有一个竞争对手", "希望有一个美好的夜晚", "不只是他一个人", "有两个人都希望去邀请我们的女孩子", "晚上可能去约会", "可能谁先早邀请", "所以这个时候啊", "或许谁的成功几率就大一些", "那我们这里啊，就去演示一下", "其中一个会落败", "两个县城进行竞争的时候", "其实就是后面去修改那个落败", "那谁落败呢", "我们下面打开我们的 IDE ", "然后在这个类的基础上去写我们下一个类", "所以我们复制一下这个新的类的名字呢，叫做 to threads competition ", "我们前面这个保持不变", "好，在这个类中", "然后呢，我们在这里写一个 main 函数", "因为这个方法是我们将要调用的", "在 main 函数中啊", "去做这个竞争的这个操作", "要去新建两个线程", "所以呢，把我们这个类实现一下", "runnable ", "并且重写它的 run 方法", "我们要做的事情就是很简单的 C 、 A 、 as ", "在 run 方法里面", "然后呢，我们期待它的值是没有人约的", "也就是调用我们这边的方法", "那没有人约呢", "那么新的值呢，就是一", "我们就叫做零", "也就代表着我自己，诶，约到了", "也就是说我们期待它现在的值是零", "我们并且我们会把它改成一", "那么下面我们就新建一个这个 RUNNABLE 对象", "把它取名叫做 R ", "然后呢，这个 R 会被传到两个线程里面", "它默认啊，我们 value 把它设置成是零", "这样就符合它这个初始条件", "但是呢，由于有两个线程都会去做修改", "所以只有一个线程会修改成功", "那我们先建一个 T 1", "在这个 T 1里面传入的这个是 R ", "同样呢，我们会有一个 T 2", "然后我们把它都启动起来", "T 2也启动起来", "T 1启动起来", "然后呢，我们对他们都进行 join ", "并且 join 完毕之后去打印出现在的值", "我们先来运行一下", "好，这就是我们的程序", "看一看它这个值是不是我们所期待的", "两个线程执行完毕之后", "应该来说啊", "它的值会变成一", "好，果然是一", "但是这样的话，你只说明了两个线程有一个成功", "但是你明显这个还不够直观嘛", "就用打断点的方式", "一个失败", "所以我们现在啊", "来具体的展开来看一下", "然后啊，要把这个断点设置为针对于现成的", "把断点打在这里", "那么我们首先呢", "介绍过如何调试多线程的程序", "我们之前也有一个彩蛋呢", "就是在这边呢，控制它的断点的范围", "然后呢，我们再去 debug 它", "它只响应到某一个线程", "在这里呢", "ok ", "我们运行它 debug", "会比我们的 run 要稍长一些", "第一次的时间呢", "那好，现在已经过来了", "还要做一些额外的准备", "我们先来看这是第几个线程啊", "我们看这是 thread 0", "我们为了让它更直观啊", "那也就是我们的线程一", "把名字稍改一下", "给它附一个名字叫做 thread 1", "thread 2", "下面那个也是一样", "默认的名字是从零开始的", "这样呢，就不会看错了", "但是我们这边的命名呢，是从一开始的", "并且我们再把刚才的一个小小的拼写错误", "然后这里呢，是 competition n 结尾的", "给修复一下", "我们重新去 debug 它", "OK ，那修复完毕之后", "好，这边呢，可以看出线程一已经进来了", "那我们看一下线程一", "第一个", "他拿到的都是一些什么样的数据啊", "它所期望的这个 expected value ", "看到我鼠标这里它是零", "这是传进来的", "大家看这里就可以啊", "new value 是一", "重点还是要看 old 的 value ", "这肯定没问题", "而且这边的 value 也就是真正的这个值", "拿到它是零", "这边的 old value 呢", "它也是零", "所以呢，既然拿到的是零", "那肯定是符合了", "那我们就来对比这个是不是符合", "可以看出第一个线程", "那我们往下走一步", "因为零等于零", "由于通过了这个 if 判断", "并且把我们的 value 啊，改成了一", "所以呢，它可以走到下一步", "现在这里我们看到这边 value ，很明显", "那我们再来看一下", "这边的 value 呢，是一", "可以看出 value 是一", "我们放大一下", "就是他之前返回的那个值是零", "并且 old 的 value 是零", "然后呢，他就执行完毕了", "这个时候已经是第二个线程了", "你再往下", "在这边是有显示的", "怎么看到是哪个线程啊", "我们放大一下看，这边是 thread 2", "这个 synchronized 方法之后", "所以第一个线程执行完了", "于是呢，他也进来了", "然后第二个线程拿到锁", "他退出了", "你去看它的 old value 和 value 都是一", "但是这个时候呢", "那 old value 是一", "它会不会进到这个 if 语句", "我们的 expected value 是零", "我们快来点一下", "肯定不会", "下一步。你看他直接跳过了 if 就到这边了", "所以呢，他没有去执行这边的一个修改操作", "但是发现比较不符合他的预期", "他去比较", "所以比较之后就不修改", "就是当前的这个值", "返回的这个 old value 啊", "所以它返回一", "当前的这个值呢，就是一", "我们最后呢，会打印出是一", "这样一来", "不过呢，最重点的地方", "这边打印出来是一", "还是在刚才的这个比较的过程中", "我们用 debug 的方式看到了第一个线程", "并且去判断零和我现在的期待的值是相等的", "它拿到了零", "于是去改", "和我期待的值零不一样", "他拿到的是一", "而第二个线程呢", "于是他不改", "所以啊，相当于我们有了等价代码之后", "把整个内部的过程都可以看得非常清楚", "已经理解的比较透彻了", "相信小伙伴们对于 CAS 啊", "这样一来", "所以啊，在讲完了这样的案例之后", "ca as 有哪些非常典型的应用场景", "我们再来看一看", "首先呢，就是说在 JUC 这个包中啊", "实际上 CAS 用的还是蛮多的", "不需要去互斥同步锁", "又能提高它的性能", "既能保证安全性", "那么一个典型的例子呢", "我们在讲乐观锁的时候啊", "就是我们的乐观锁", "讲过它底层呢，也是利用 CAS 实现的", "它在修改的时候", "比如说我们的数据库啊", "那么它是可以用版本号的方式去进行修改", "而不需要锁住这个表", "这样的思想呢，正是 CAS 思想的体现", "另外呢，我们的并发容器中也有很多 c a as 的体现", "比如说我们举一个 concurrent hashmap 的例子", "我们在讲并发容器的时候", "在这里呢，我们可以现在进去看看", "好，它的重要的方法我们都分析过", "包括 put 方法、 get 方法", "那我们就看一下他的 put 方法", "找一下", "好在 put 方法里面呢", "大家可以看到这里非常明显的一个 cs 操作", "我们把旁边的收一下", "它的方法名就叫做 CAS ", "也有对这种思想的运用", "所以在我们的 concurrent hashmap 中", "我们的原子类中也有运用原子类啊", "不仅如此呢", "就是我们上一章所讲的那个 atomic long 、 atomic integer ", "也有对 C 、 A 、 as 的运用", "那么原子类是怎么运用的呢", "下面我们就分析一下在 java 中", "原子类是如何利用 cs 实现自己原子操作的", "我们先用文字呢", "然后呢，我们再去通过源码来一一的对应下来", "对它进行一个大概的了解", "首先一个它会加载一个 on safe 工具", "所以啊，实际上是通过这个工具", "这个工具呢，可以用来直接操作内存", "来实现了底层的操作", "并且呢，我们还需要用 volatile 来修饰这个 value 字段", "来保证它的可见性", "那么多个线程之间不能看到最新的数据", "如果不加的话", "那也是线程不安全的", "下面呢，我们就用这个方法作为我们的突破口", "来到我们的这个原子类代码中", "来看一下它是怎么实现的", "所以在这里新建一个", "以我们 atomic integer 为例", "好", "进入到这个类中去", "我们先来看这边的加载", "然后呢，我们一一来对应啊", "在这个类中呢，有这么一块代码", "on safe 工具是在哪里实现的", "不知道小伙伴们熟不熟悉这个语法", "这个语法是一个初始静态代码块的这么一个语法", "所以呢，这部分会被最开始就执行", "然后你可以看到啊", "而它呢，正是利用我们 on safe 去拿到的", "它有了这样一个 offset ", "他拿到的是我们 atomic integer 这个类中", "value 这个字段的地址", "正好在这里", "那我们 value 字段在哪里呢", "那这个 value 呢，对应我们这边的第三点", "这个 int value ", "我们看一下", "也就是用 volatile 修饰它", "这样一来它就可以保证可见性", "果然在这边呢，是用 volatile 修饰了这个 value ", "所以接下来我们再来看下一个重要的方法", "我们以一个方法为例", "比如说这边的 get and ADD ", "下面调用的是 unsafe ", "那这个 get and ADD 呢", "他的 get and and int 这个方法", "好，这个类呢是 unsafe 类", "这个方法中我们点进去看一下", "已经跳到了 unsafe 的这个方法中", "那我们看一下这个代码呀", "首先很明显的是可以看出它是一个 do while 循环", "那么 do while 循环呢", "他就明显用了这个 compare and swap int ", "在这个 while 的判断条件里面", "这正是我们 CAS 的思想的体现", "也就是 compare and swap ", "这个方法呢，就是一个 native 方法", "我们再来看这个方法", "然后呢，在这里如果说他这一次 cs 失败的话", "我们等一会看一下它的代码", "这个 VAR 5呢", "他就会进行重试", "所以啊，这边的 c a as 加上我们的这个自旋", "是我们最后将要返回的那个旧值", "整个呢，就形成了一个乐观锁", "do while 是一个自旋", "它也会进行重试", "如果这一次更新失败", "这个 on safe 是什么东西", "那么小伙伴们可能会说了", "那我们就来对它进行一下简要的介绍", "我之前没有接触过", "on safe 啊，它是我们 CAS 的核心类", "无法直接访问底层的操作系统", "因为我们的 java 呢", "所以它需要用一些其他的办法来实现", "因为啊，我们的 java 无法访问底层操作系统", "如果想访问的那都是 native 方法", "在 JDK 中呢，有一个 unsafe 的类", "不过呀， JVM 还是给我们开了一个后门", "这个 unsafe 类呢，它提供了硬件级别的原子操作", "我们在刚才呢，拿到了一个 value offset ", "是在这里看到在 atomic integer 中", "我们在这边呢，通过这里拿到了一个 value offset ", "它是什么意思呢", "它就是我们这个类里面的这个 value 的", "所以我们就有了这个变量", "有了这个地址之后", "它的地址", "在内存中的一个偏移地址", "我们就可以用 unsafe 直接操作这个地址了", "通过这个地址我们可以获取原值", "那么这里还有一个关键点，就是说 unsafe ", "也可以写入新值", "你看你看到哪里就截止了", "然后呢，你发现它是 native 的", "看到这边 compare and swap int ", "那你这个 native 确实有点难受啊", "你如果还想进一步探索这个 native 做了什么事情的话", "那么在这里我跟小伙伴们分享一下", "unsafe 的这个 compare and swap int ", "在这里啊", "它的实现呢，在我们的 on safe 点 CPP 中", "它是一个 native 的方法", "这是一个 C 加加代码", "如关于如何去从 java 代码对应到 C 加加代码", "这个过程以及这个方法呀", "我们在 java 并发精讲的那个课程中", "那么在此呢，我把这个 C 加加代码贴上来", "有一个彩蛋进行了介绍", "让小伙伴们看一下", "这个就是它的代码", "那么具体来讲，大家看可能会很困难", "可能小伙伴们都不熟悉", "包括语法", "因为不仅是内容", "我们来对它进行一下简单的介绍", "这毕竟不是同一个语言", "首先呢，他是想办法拿到我们的内存地址", "利用我们的偏移量 offset 拿到了地址", "他在这一行语句中", "并且有了地址之后", "并且传入我们的地址去进行 CAS 操作", "利用了这行语句", "而其中最关键的应该是这里", "也就是 atomic c m p x c h g 这个语句啊", "实现了原子性的比较和替换", "这个 X 参数啊，是即将更新的值", "其中这里的 X 呢，这个参数", "而这个 E 呢，是我们的原值", "然后呢，再加上它的这个 address 内存地址", "如果还想进一步深究它是怎么实现呢", "它就可以完成这个操作", "那就需要对应到机器指令和汇编了", "那我认为呢，我们没有必要去深入到如此底层", "因为在平时开发中", "我们深入到 native 实现就已经足够了", "所以啊，我们来做一下总结", "它首先是利用了 unsafe 这个类", "在我们的 atomic integer 中", "来帮助我们操作底层", "然后呢，尤其是利用了里面的 compare and swap int 这个方法", "我们先是想办法拿到在内存中的地址", "在这个方法中呢", "有了地址之后", "去实现原子性的比较和替换", "我们就可以利用这样的指令", "最后呢，就完成了整个 c a as 的操作", "所以以上啊，我们就以 atomic integer 为一个例子", "具体分析了它是如何一步一步利用 CAS ", "实现了线程安全的", "下面呢，我们来看一下 CAS 的缺点", "CAS 啊，它有几个缺点", "是 ABA 问题", "首先最大的缺点呢", "这里的 AABA 问题我跟小伙伴们解释一下", "首先他在 compare and swap 的时候", "但是他检查", "他是先检查对不对", "它只是检查是不是和我这个值相等", "它并不是检查在此期间是不是真的被修改过", "那么我们举一个例子", "然后呢，我发现它现在是5 K ", "比如说我拿到这个值", "我就去进行计算了", "有第二个线程把五改成了七", "那在我计算的过程中", "把七又改回了五", "又有第三个线程呢", "我去看它现在是不是五", "等到我第一个线程计算完毕", "于是呢，我就以为在此期间", "我会发现真的是五", "没有任何线程去对它进行修改", "我就会理所当然的把这个五改成我所期待的那个值", "所以啊", "但实际上呢，在此过程中", "已经有其他人把它修改过了", "比如说我就会认为没有人、其他人修改过", "那么这样就会发生问题", "那可能我接下来的一些操作、一些逻辑", "包括一些技术都会出现问题", "我们可以沿用数据库的方式", "如何解决这个问题呢", "我们添加一个版本号", "用乐观锁的时候呢", "我们原来的那个路径原来是五变成七变成五", "这样一来啊", "你可能由于最开始和最后都是五", "你可能看不清楚", "就会变成版本一、版本二、版本三", "但是我们加了版本号之后呢", "这样一来，我们直接去对比这个版本号", "要比我们直接对比这个值", "所以我们可以用这样的思路来解决 ABA 问题", "来的更靠谱一些", "这个 AABA 第一个 A 和第三个 A ", "实际上指的就是我们一开始的五和最后的五", "而这里的 B 呢，就是我们刚才所说的七", "第二个缺点呢，在于它的自旋时间可能会比较长", "这是 CES 的一个明显的缺点", "我们刚才看到有一些操作啊", "那么在这种情况下", "它是死循环的", "相当于是一个很长时间的自旋", "那如果在此期间它的竞争非常激烈", "那这个自旋啊，它是消耗 CPU 的", "或者锁他一直都拿不到", "它对性能是一种很大的消耗", "所以这也是 cs 的一个缺点", "下面我们来总结一下 CAS 原理这一章", "我们讲解了什么是 CAS ", "在这一章中呢", "CAS 啊，实际上用这幅图是可以比较明显的看出来的", "它就是先去比较", "然后呢再去回过来操作", "然后呢，我们写了一个案例", "就是两个县城去竞争", "这个案例啊", "第一个县城成功了", "去竞争的时候呢", "发现已经被改过了", "第二个线程去比较的时候", "同时我们也通过这个案例", "所以第二个线程落败", "明白了 CAS 的等价代码", "以及它内部的工作原理", "它最典型的应用场景啊，有三个", "然后呢，我们讲解了它的应用场景", "分别是乐观锁、并发容器和原子类", "在这些场景中都用到了 cs 原理和他的思想", "然后呢，我们以 atomic integer 为突破口", "从最顶层的代码呢", "逐层分析了它的源代码", "以及还看到了 unsafe 它的 native 实现", "一直到 unsafe 的代码", "明白了他是如何一步一步利用 cs", "当然最本质的是要 CPU 支持这样的指令", "实现原子操作的", "最后我们还是要操作 CPU 的", "利用 CPU 的原子指令来保证它的原子性", "并且第五呢，我们还看了他的缺点", "cs 最典型的两个缺点啊，是 AABA 问题", "以及自旋带来的性能消耗问题", "以上呢，就是我们对于 cs 这章的讲解", "谢谢小伙伴", "7-1 什么是CAS", "7-2 CAS的等价代码、使用案例", "7-3 CAS的应用场景、源码分析", "7-4 CAS的缺点和总结"]