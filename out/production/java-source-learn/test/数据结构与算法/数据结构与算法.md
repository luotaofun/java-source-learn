---
title: 数据结构与算法
date: 2025-05-8 22:00:22
tags: 数据结构与算法

---
![image-20250510174152404](./数据结构与算法/image-20250510174152404.png)

## 判断一个数是否是 2 的 N 次方

在二进制下，2 的 N 次方的数只有一个 1，其余都是 0。

- 例如：1（0001）、2（0010）、4（0100）、8（1000）、16（10000）……

如果 n 是 2 的 N 次方，那么 n-1 的二进制会把这个唯一的 1 变成 0，后面全变成 1。

- 例如：8（1000）-1 = 7（0111）

把 n 和 n-1 做按位与（&），结果一定是 0。

- 8 & 7 = 1000 & 0111 = 0000

```python
def is_power_of_two(n):
    ''' 判断一个数是否是 2 的 N 次方 '''  
    if n <= 0: # 0 不是 2 的 N 次方，所以要先排除
        return False
    return (n & (n - 1)) == 0
```

 ## 评价算法的两个指标：
> - 1. 时间复杂度：运行一个程序所花费的时间
> - O(1): 常量阶最优效率，1表示常数，所有能确定的数字都用O(1)
> - O(logn): 对数阶
> - O(n): 线性阶
> - O(nlogn): 线性对数阶
> - O(n^2): 平方阶
> - O(n^n): 指数阶（n的n次方）
> - 2. 空间复杂度：运行程序所需要的内存

```java
package test.数据结构与算法;
/**
* @Description:
 ## 评价算法的两个指标：
> - 1. 时间复杂度：运行一个程序所花费的时间
> - O(1): 常量阶最优效率，1表示常数，所有能确定的数字都用O(1)
> - O(logn): 对数阶
> - O(n): 线性阶
> - O(nlogn): 线性对数阶
> - O(n^2): 平方阶
> - O(n^n): 指数阶（n的n次方）
> - 2. 空间复杂度：运行程序所需要的内存
* @Author: LuoTao
* @Date: 2025-05-09 07:21:55
**/
class BigO {

/*
    void o1(){
        int a=0;
        int n=3; //这里运行了1次，时间复杂度为O(1)
        for (int i = 0; i < n; i++) { //条件会被检查4次，在第四次的时候跳出循环:i=3 (0 1 2 3)
            a+=1; // 这里运行了3次，时间复杂度为O(1)，因为 n 已经确定了，是常量
        }
    }

    void on(){
        int a=0;
        for (int i = 0; i < n; i++) { // n表示未知,a是一个不确定的变量
            a +=1;// 这里运行n次，时间复杂度为O(n)
        }
    }

    void logn(){
        int i=1;
        while(i <= n){
            i = i * 2; // i的值：2^1 2^2 2^3 2^4 ... 2^x，所以这里运行x次
            */
/**
             对数的性质: log_b(b^a)=a
             2^x=n 求x：
             > 对原方程两边取以2为底的对数得到：log_2(2^x)=log_2(n)
             > 根据对数的性质化简得到：x=log_2(n)
             > 由于计算机忽略掉常数，所以这里时间复杂度为O(logn)
             **//*

        }
    }

    void nlogn(){
        int i=1;
        for (int j = 0; j < n; j++) { // n表示未知
            while(i <= n){
                i = i * 2; // 内层循环的时间复杂度为O(logn)，循环结束后时间复杂度为O(nlogn)
            }
        }
    }

*/


    public static void main(String[] args) {
        int counti=0;
        int countj=0;
//        int n=0; // 内层循环体执行 n 次
//        int n=1; // 内层循环体执行 n-1 次
        int n=2; // 内层循环体执行 n-2 次
        int i=0;
//        int i = n;
        for (; i < n; i++) { // 条件会被检查  n + 1 次（最后一次判断不满足条件退出循环），外层循环体执行了 n 次
            System.out.println("i=" + i);
            // i=0  内层循环体执行了 n 次
            // i=1  内层循环体执行了 n-1 次
            // i=2 内层循环体执行了 n-2 次
            // i=n 内层循环体执行了 n-i 次
            counti += 1;
            int countinner = 0;
            for (int j = i; j < n; j++) { //n n-1 n-2  当i=n时内层循环体执行 n-i 次
                System.out.println("    j=" + j);
                countj += 1;
                countinner += 1;
            }
            System.out.println("    当前内层循环执行次数" + countinner);
        }
        System.out.println("==================================" );
        System.out.println("O(n)外层循环体执行总次数n" + counti);
        System.out.println("O(n²)内层循环体执行总次数" + countj);
        // 总和 = 项数 × (首项 + 末项) ÷ 2
        // n + (n-1) + (n-2) + ... + 2 + 1= n(n+1)/2
    }
}

```

## ArrayList数组？

> - JDK封装了数组，并且封装了数组的扩容机制。
> - 往中间增删O(N)元素效率很低，因为数组是连续的内存块，存储相同类型的数据，为了保证连续性会涉及元素的移动过程（大量的数据搬移）。
> - 查询效率高O(1)，因为支持随机访问，即可以通过下标定位到素质中的某一个元素。
> - 如果知道数据的大小又很关注性能，就选用数组。数组需要关注的就是越界。

## 为什么数组的下标要从0开始？
> - 理论上的合理选择,是基于计算机底层原理和性能优化的结果，CPU 寻址方式天然支持偏移量从0开始。
> - 数组是连续的内存块,访问任意元素的地址可以通过公式计算  address = baseAddress + index * elementSize
> - 如果从0开始，那第一个元素的地址就刚好是 baseAddress + 0 * elementSize = baseAddress，也就是数组的起始地址。这种计算非常直接，不需要额外处理。
> - 如果从1开始，那每次访问都要做一次减法：index - 1，才能得到正确的偏移量，这就增加了不必要的开销。

```java
package test.数据结构与算法;

import java.io.*;
/**
 * @Classname MyArray
 * @Description
## ArrayList数组？

> - JDK封装了数组，并且封装了数组的扩容机制。
> - 往中间增删O(N)元素效率很低，因为数组是连续的内存块，存储相同类型的数据，为了保证连续性会涉及元素的移动过程（大量的数据搬移）。
> - 查询效率高O(1)，因为支持随机访问，即可以通过下标定位到素质中的某一个元素。
> - 如果知道数据的大小又很关注性能，就选用数组。数组需要关注的就是越界。

## 为什么数组的下标要从0开始？
> - 理论上的合理选择,是基于计算机底层原理和性能优化的结果，CPU 寻址方式天然支持偏移量从0开始。
> - 数组是连续的内存块,访问任意元素的地址可以通过公式计算  address = baseAddress + index * elementSize
> - 如果从0开始，那第一个元素的地址就刚好是 baseAddress + 0 * elementSize = baseAddress，也就是数组的起始地址。这种计算非常直接，不需要额外处理。
> - 如果从1开始，那每次访问都要做一次减法：index - 1，才能得到正确的偏移量，这就增加了不必要的开销。

 *
 * @Version 1.0.0
 * @Date 2025/5/9 11:13
 * @Author LuoTao
 */
public class MyArray {
    /**
     * @Description 用数组实现统计文件中的年龄段出现的次数,年龄和数组下标对应
     **/
    public static void countAge() throws IOException {
        String str = null;
        String fileName = "D:\\workspace\\java-projects\\java-source-learn\\src\\test\\数据结构与算法\\data.txt";
        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(fileName), "UTF-8");

        long startTime = System.currentTimeMillis();
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
        int total = 0; // 数组中元素的实际大小
        int[] data = new int[20]; // 存储[1,20]每个值出现的次数
        while ( (str = bufferedReader.readLine()) != null ){ // O(n)
            int age = Integer.valueOf(str);
            data[age] ++; //  每个年龄段出现的次数
            total ++;
        }
        for (int i = 0; i < 20; i++) {
            System.out.println(i + "出现次数:" + data[i]);
        }
        System.out.println("花费时间：" + (System.currentTimeMillis() - startTime) + "ms");
    }


    class ArrayTest{
        private int size;   // 数组长度
        private int data[]; // 保存数据的数组
        private int index;  // data数组实际数据大小

        // 数组初始化
        public ArrayTest(int size) {
            this.size = size;
            this.data = new int[size];
            this.index = 0;
        }

        public void print(){
            System.out.println("index:" + index);
            for (int i = 0; i < index; i++) {
                System.out.println(data[i] + " ");
            }
            System.out.println();
        }

        /**
         * @Description
         * 1 判断数组是否还有空间：
         *      1.1 如果没有则扩容
         *      1.2 如果有空间存储，将插入位置loc之后的数据后移
         * 2 插入成功则元素个数+1
         * @Author LuoTao
         * @Date 2025/5/10 15:13
         * @return void
         * @param loc 插入元素的位置
         * @param n
         **/
        public void insert(int loc,int n){ // O(n)
            if (index ++ < size){ // 判断是否有空间存储否则扩容
                for (int i = size -1; i > loc; i--) { // 将插入位置loc之后的数据后移;size -1表示最后一个元素；
                    data[i] = data[i - 1]; // 数据后移
                }
                data[loc] = n; // 当size -1==loc时，直接赋值插入数据不用数据后移
                index ++; // 元素个数加1
            }
            // TODO: 扩容
        }

        /**
         * @Description
         * 1 判断删除元素位置是否为最后一个元素
         *      1.1 当删除元素位置不为最后一个元素时，数据前移；
         *      1.2 当删除元素位置为最后一个元素时，删除最后一个元素。
         * 2 删除成功则元素个数-1
         * @Author LuoTao
         * @Date 2025/5/10 15:11
         * @return void
         * @param loc 删除元素的位置
         **/
        public void delete(int loc){// O(n)
            for (int i = loc; i < size; i++) {
                if(i != size -1){ // 当删除最后一个元素时，不能数据前移
                    data[i] = data[i + 1]; // 数据前移
                }else{
                    data[i]=0; // 删除最后一个元素
                }
            }
            index --; // 删除元素，元素个数减1
        }

        public void update(int loc,int n){// O(1)
            data[loc] = n;
        }

        public int get(int loc){// O(1)
            return data[loc];
        }

    }
}

```



## 堆内存（Heap）?

> - 所有线程共享的一块内存区域。
> - 垃圾回收器（GC）自动管理堆内存。
> - 存储对象实例（包括数组）。
> - 生命周期由对象决定，当对象不再被引用时，可能会被回收。

## 栈内存（Stack）?

> - 每个线程拥有自己的私有栈。
> - 存储方法调用时的局部变量、基本类型、参数传递、方法调用过程中的`上下文`等信息,因为栈的速度比堆`快`，而且栈的数据可`共享`。
> - 局部变量如果是基本类型，直接保存值；如果是引用类型，则保存指向堆中对象的`引用`。
> - 方法执行完毕后，栈帧自动弹出，局部变量随之销毁。

```java
package test.数据结构与算法;

/**
 * @Classname HeapAndStack
 * @Description 堆栈
## 堆内存（Heap）?

> - 所有线程共享的一块内存区域。
> - 垃圾回收器（GC）自动管理堆内存。
> - 存储对象实例（包括数组）。
> - 生命周期由对象决定，当对象不再被引用时，可能会被回收。

## 栈内存（Stack）?

> - 每个线程拥有自己的私有栈。
> - 存储方法调用时的局部变量、基本类型、参数传递、方法调用过程中的`上下文`等信息,因为栈的速度比堆`快`，而且栈的数据可`共享`。
> - 局部变量如果是基本类型，直接保存值；如果是引用类型，则保存指向堆中对象的`引用`。
> - 方法执行完毕后，栈帧自动弹出，局部变量随之销毁。

 * @Version 1.0.0
 * @Date 2025/5/10 16:21
 * @Author LuoTao
 */
public class HeapAndStack {
    public static void main(String[] args) {
        String str1 = "abc"; // 在栈中创建变量 str1，先不会创建 abc 而是先在栈中找有没有 abc，如果有直接指向，否则就加一个 abc 进来。
        String str2 = "abc"; // 创建一个变量 str12,直接指向已有的 abc
        System.out.println(str1 == str2); // true

        str1 = "bcd"; // str1 指向一个新的 bcd,而 str2 仍然指向 abc
        System.out.println(str1 == str2); // false,虽然栈的数据可`共享`，但是每个线程拥有自己的私有栈，不会影响 str2

        String str4 = "bcd";
        System.out.println(str1 == str4); // true,str1 和 str4 指向同一个bcd,并没有新建对象

        str1 = new String("abc");
        System.out.println(str1 == str2); // false,new 在存储在堆内存中，新开了一个对象，而 str2 仍然在栈内存中

        String s1 = "ja";
        String s2 = "va";
        String s3 = "java";
        String s4 = s1 + s2;// 加号在 JDK 是做了重载的，调用了线程不安全的 StringBuilder（性能更高，在绝大多数字符串拼接场景中，都是单线程操作） 的 append 方法，会 new 对象，所以 s4 是在堆内存中创建的，s3 是在栈内存中创建的
        System.out.println(s3 == s4 ); // false
        System.out.println(s3.equals(s4) ); // true,只比较值
    }
}

```



## HashMap的数据结构？

> JDK1.7-数组+链表
>
> JDK1.8-数组+链表+红黑树
